

javascript:
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Initliazing the game

let upPressed = false;
let downPressed = false;
let leftPressed = false;
let rightPressed = false;
let playerCanMove = false;



const main = document.querySelector('main');

//Player = 2, Wall = 1, Enemy = 3, Point = 0
let maze = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 2, 0, 1, 0, 0, 0, 0, 3, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    [1, 3, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 1, 1],
    [1, 0, 0, 1, 0, 3, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 3, 1, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
];

//Populates the maze in the HTML
// ... (previous code remains the same)

//Populates the maze in the HTML
//Populates the maze in the HTML
//Populates the maze in the HTML
for (let y = 0; y < maze.length; y++) {
    for (let x = 0; x < maze[y].length; x++) {
        let block = document.createElement('div');
        block.classList.add('block');

        switch (maze[y][x]) {
            case 1:
                block.classList.add('wall');
                break;
            case 2:
                block.id = 'player';
                let mouth = document.createElement('div');
                mouth.classList.add('mouth');
                block.appendChild(mouth);
                break;
            case 3:
                // Create the enemy
                let enemyContainer = document.createElement('div');
                enemyContainer.classList.add('enemy-container');
                block.appendChild(enemyContainer);

                let enemy = createEnemyElement();
                enemyContainer.appendChild(enemy);
                break;
            default:
                block.classList.add('point');
                block.style.height = '1vh';
                block.style.width = '1vh';
                    if (maze[y][x] !== 3) {
            block.classList.add('point');
            block.style.height = '1vh';
            block.style.width = '1vh';
        }     
        }   

        main.appendChild(block);
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Function to create a new enemy element

function createEnemyElement() {
    let enemy = document.createElement('div');
    enemy.classList.add('enemy');

    let earLeft = document.createElement('div');
    earLeft.classList.add('ear', 'ear-left');
    enemy.appendChild(earLeft);

    let earRight = document.createElement('div');
    earRight.classList.add('ear', 'ear-right');
    enemy.appendChild(earRight);

    let headTop = document.createElement('div');
    headTop.classList.add('head-top');
    enemy.appendChild(headTop);

    let head = document.createElement('div');
    head.classList.add('head');
    enemy.appendChild(head);

    let eyeLeft = document.createElement('div');
    eyeLeft.classList.add('eye', 'eye-left');
    head.appendChild(eyeLeft);

    let eyeRight = document.createElement('div');
    eyeRight.classList.add('eye', 'eye-right');
    head.appendChild(eyeRight);

    let body = document.createElement('div');
    body.classList.add('body');
    enemy.appendChild(body);

    let armLeft = document.createElement('div');
    armLeft.classList.add('arm', 'arm-left');
    enemy.appendChild(armLeft);

    let armRight = document.createElement('div');
    armRight.classList.add('arm', 'arm-right');
    enemy.appendChild(armRight);

    return enemy;
}

// Function to position the enemies correctly
function positionEnemies() {
    const enemies = document.querySelectorAll('.enemy-container');
    for (let i = 0; i < enemies.length; i++) {
        let enemy = enemies[i];
        let block = enemy.parentNode;
        let blockRect = block.getBoundingClientRect();
        enemy.style.top = `${blockRect.top}px`;
        enemy.style.left = `${blockRect.left}px`;
    }
}

positionEnemies();

function positionEnemies() {
    const enemies = document.querySelectorAll('.enemy-container');
    for (let i = 0; i < enemies.length; i++) {
        let enemy = enemies[i];
        let block = enemy.parentNode;
        let blockRect = block.getBoundingClientRect();
        let x = blockRect.left + (blockRect.width - enemy.offsetWidth) / 2;
        let y = blockRect.top + (blockRect.height - enemy.offsetHeight) / 2;
        enemy.style.top = `${y}px`;
        enemy.style.left = `${x}px`;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Player movement
function keyDown(event) {
    if (playerCanMove) {
        event.preventDefault(); // Prevent scrolling
        switch (event.key) {
            case 'ArrowUp': upPressed = true; break;
            case 'ArrowDown': downPressed = true; break;
            case 'ArrowLeft': leftPressed = true; break;
            case 'ArrowRight': rightPressed = true; break;
        }
    }
}


function keyUp(event) {
    if (playerCanMove) {
        switch (event.key) {
            case 'ArrowUp': upPressed = false; break;
            case 'ArrowDown': downPressed = false; break;
            case 'ArrowLeft': leftPressed = false; break;
            case 'ArrowRight': rightPressed = false; break;
        }
    }
}

const player = document.querySelector('#player');
const playerMouth = player.querySelector('.mouth');
let playerTop = 0;
let playerLeft = 0;


document.addEventListener('keydown', keyDown);
document.addEventListener('keyup', keyUp);
document.getElementById('lbttn').addEventListener('click', () => {leftPressed = true; setTimeout(() => leftPressed = false, 100);});
document.getElementById('ubttn').addEventListener('click', () => {upPressed = true; setTimeout(() => upPressed = false, 100);});
document.getElementById('rbttn').addEventListener('click', () => {rightPressed = true; setTimeout(() => rightPressed = false, 100);});
document.getElementById('dbttn').addEventListener('click', () => {downPressed = true; setTimeout(() => downPressed = false, 100);});

// Reference to the start button and the start div
const startBtn = document.querySelector('.start');
const startDiv = document.querySelector('.startDiv');

// Function to initiate the game
function startGame() {
  // Hide the start button
  startDiv.style.display = 'none';
  // Allow player movement
  playerCanMove = true;
}

// Event listener for the start button
startBtn.addEventListener('click', startGame);

////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Function to check for collisions between the player and walls

////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Core Player Movement Logic

setInterval(function () {
    if (playerCanMove) {
        let position = player.getBoundingClientRect();
        let nextTop = position.top - (upPressed ? 1 : 0) + (downPressed ? 1 : 0);
        let nextBottom = position.bottom + (downPressed ? 1 : 0) - (upPressed ? 1 : 0);
        let nextLeft = position.left - (leftPressed ? 1 : 0) + (rightPressed ? 1 : 0);
        let nextRight = position.right + (rightPressed ? 1 : 0) - (leftPressed ? 1 : 0);

        // Only move if no collision is detected
        if (checkWallCollisions(nextTop, nextBottom, nextLeft, nextRight)) {
            if (downPressed) {
                playerTop++;
                player.style.top = playerTop + 'px';
                playerMouth.classList = 'down';
            } else if (upPressed) {
                playerTop--;
                player.style.top = playerTop + 'px';
                playerMouth.classList = 'up';
            } else if (leftPressed) {
                playerLeft--;
                player.style.left = playerLeft + 'px';
                playerMouth.classList = 'left';
            } else if (rightPressed) {
                playerLeft++;
                player.style.left = playerLeft + 'px';
                playerMouth.classList = 'right';
            }
        }
    }
    checkEnemyCollision();
    checkScoreCollisions(); 
}, 1);

// Define a grid-based collision detection system
const gridSize = 10;
const grid = [];
for (let y = 0; y < maze.length; y++) {
  grid[y] = [];
  for (let x = 0; x < maze[y].length; x++) {
    grid[y][x] = maze[y][x] === 1 ? 'wall' : 'empty';
  }
}

// Define a function to check for collisions
function checkCollision(x, y) {
  if (x < 0 || x >= maze[0].length || y < 0 || y >= maze.length) {
    return true; // out of bounds
  }
  return grid[y][x] === 'wall';
}

// Update the player movement logic
function movePlayer(dx, dy) {
  const newX = playerLeft + dx;
  const newY = playerTop + dy;
  if (!checkCollision(newX, newY)) {
    playerLeft = newX;
    playerTop = newY;
  }
}

// Update the game loop to use the new movement logic
setInterval(() => {
  if (upPressed) {
    movePlayer(0, -1);
  } else if (downPressed) {
    movePlayer(0, 1);
  } else if (leftPressed) {
    movePlayer(-1, 0);
  } else if (rightPressed) {
    movePlayer(1, 0);
  }
}, 16); // 16ms = 60fps

function checkWallCollisions(nextTop, nextBottom, nextLeft, nextRight) {
    // Get the elements at the player's next position corners
    let topLeftElement = document.elementFromPoint(nextLeft, nextTop);
    let topRightElement = document.elementFromPoint(nextRight, nextTop);
    let bottomLeftElement = document.elementFromPoint(nextLeft, nextBottom);
    let bottomRightElement = document.elementFromPoint(nextRight, nextBottom);

    // Check if any of these elements have a class of 'wall'
    if (topLeftElement.classList.contains('wall') || 
        topRightElement.classList.contains('wall') ||
        bottomLeftElement.classList.contains('wall') ||
        bottomRightElement.classList.contains('wall')) {
        // There's a wall, so don't allow movement
        return false;
    }
    // No collision detected
    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Function to check for collisions between the player and enemies

let lives = 3; // Initialize lives to 3
// let lives = 3; // Initialize lives to 3
let invulnerable = false; // New flag to track invulnerability

function checkEnemyCollision() {
    // If the player is invulnerable, exit the function to avoid multiple hits
    if (invulnerable) return;

    const enemies = document.querySelectorAll('.enemy');
    const playerRect = player.getBoundingClientRect();

    for (let enemy of enemies) {
        const enemyRect = enemy.getBoundingClientRect();
        if (playerRect.left < enemyRect.right && playerRect.right > enemyRect.left &&
            playerRect.top < enemyRect.bottom && playerRect.bottom > enemyRect.top) {
            // Collision detected, flash player and decrement life
            player.classList.add('hit');
            setTimeout(() => player.classList.remove('hit'), 1500); // Flash for 2 seconds
            
            lives--;
            updateLivesDisplay();
            makePlayerInvulnerable(); // Call this to make the player invulnerable for a short time

            if (lives === 0) {
                gameOver();
                player.classList.remove('hit');
                player.classList.add('dead');            
            }
            break; // Only handle one collision at a time
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Core gameplay logic
function makePlayerInvulnerable() {
    invulnerable = true;
    // Set a timeout for how long the player should be invulnerable after being hit
    setTimeout(() => {
        invulnerable = false;
    }, 1500); // The player is invulnerable for 2 seconds
}



function updateLivesDisplay() {
    const livesList = document.querySelector('.lives ul');
    livesList.innerHTML = ''; // Clear current lives
    for (let i = 0; i < lives; i++) {
        const life = document.createElement('li');
        livesList.appendChild(life);
    }
}

function gameOver() {
    playerCanMove = false;
    player.classList.add('dead'); // Add a 'dead' class to change the styling
    playerMouth.style.display = 'none'; // Hide the mouth to stop animation
    showGameOverScreen();
}

function showGameOverScreen() {
    const gameOverDiv = document.createElement('div');
    gameOverDiv.classList.add('game-over'); // This class is already styled above
    
    const gameOverMessage = document.createElement('h1');
    gameOverMessage.textContent = 'Game Over';
    gameOverMessage.classList.add('game-over-btn'); // Use this class for text styling
    gameOverDiv.appendChild(gameOverMessage);
    
    const restartBtn = document.createElement('button');
    restartBtn.textContent = 'Restart';
    restartBtn.classList.add('restart-btn'); // Use this class for button styling
    restartBtn.onclick = restartGame;
    gameOverDiv.appendChild(restartBtn);
    
    startDiv.innerHTML = ''; // Clear the start div and reuse it for the game over screen
    startDiv.appendChild(gameOverDiv);
    startDiv.style.display = 'flex'; // Show the game over screen
}

const gameOverMessage = document.createElement('h1');
gameOverMessage.textContent = 'Game Over';
gameOverMessage.classList.add('game-over-text'); // Add a class for styling
gameOverDiv.appendChild(gameOverMessage);


function restartGame() {
    window.location.reload(); 
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////


// Initial call to set lives display
updateLivesDisplay();

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// //Enemy movement








////////////////////////////////////////////////////////////////////////////////////////////////////////////

// //Score Functionality

let score = 0; // Initialize the score variable

function checkScoreCollisions() {
    const playerRect = player.getBoundingClientRect();
    const points = document.querySelectorAll('.point');

    for (let point of points) {
        const pointRect = point.getBoundingClientRect();
        if (playerRect.left < pointRect.right && playerRect.right > pointRect.left &&
            playerRect.top < pointRect.bottom && playerRect.bottom > pointRect.top) {
            // Collision detected, remove the point and increment the score
            point.classList.remove('point');
            score += 5; // Increment score by 5 points
            updateScoreDisplay();
            break; // Only handle one collision at a time
        }
    }
}

function updateScoreDisplay() {
    const scoreElement = document.querySelector('.score p');
    scoreElement.textContent = `Score: ${score}`; // Update the score display
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////















////////////////////////////////////////////////////////////////////////////////////////////////////////////

// //Added Features

////////////////////////////////////////////////////////////////////////////////////////////////////////////

// // // Levelling System.
// Assisted structure to follow with AI (Claude AI + Chat GPT 4.0 Turbo Vision were used in this case) and the player.

// Here's a proposed structure for implementing a leveling system with increasing complexity for a Pacman-style game with 20 levels:

// Level 1:
// - Basic maze layout with a few obstacles
// - 3 enemy with random movement
// - Introduce point collection mechanic



// Level 2:
// - Slightly more complex maze layout
// - Introduce power-ups (e.g., invincibility for a short duration)

// Level 3:
// - Increase the number of enemies to two
// - Introduce different enemy types with unique behaviors

// Level 4:
// - More intricate maze layout with dead ends
// - Introduce teleportation portals within the maze

// Level 5:
// - Increase the number of enemies to three
// - Introduce moving obstacles or barriers

// Level 6:
// - Maze layout with narrow passages and tight corners
// - Introduce enemy spawning points

// Level 7:
// - Increase the speed of enemies
// - Introduce time-limited levels

// Level 8:
// - Maze layout with multiple sections connected by corridors
// - Introduce keys and locked doors mechanic

// Level 9:
// - Increase the number of enemies to four
// - Introduce enemy chasing behavior

// Level 10:
// - Maze layout with dynamic obstacles (e.g., moving walls)
// - Introduce boss enemy with unique abilities

// Level 11-15:
// - Gradually increase the complexity of maze layouts
// - Introduce new enemy types with advanced AI behaviors
// - Incorporate more challenging obstacles and traps
// - Increase the number of enemies per level

// Level 16-20:
// - Highly complex and large maze layouts
// - Introduce puzzle elements within the maze
// - Multiple boss enemies with unique patterns and abilities
// - Combine various mechanics introduced in previous levels
// - Increase the speed and difficulty of enemies

// Additional features to consider:
// 1. Power-ups:
//    - Speed boost
//    - Temporary invincibility
//    - Ability to pass through walls
//    - Enemy freezing

// 2. Scoring system:
//    - Implement a high score leaderboard
//    - Provide bonus points for completing levels quickly
//    - Introduce combo system for collecting multiple points in succession

// 3. Lives and checkpoints:
//    - Implement a lives system
//    - Introduce checkpoints within levels
//    - Provide extra lives as rewards for achieving certain milestones

// 4. Visual enhancements:
//    - Add animations for character movements and interactions
//    - Introduce dynamic lighting effects
//    - Implement particle effects for collectibles and power-ups

// 5. Sound and music:
//    - Add sound effects for character actions and events
//    - Introduce background music that changes based on the level or situation

// Remember to gradually introduce new mechanics and increase the difficulty as the player progresses through the levels. Playtest and iterate on the level designs to ensure a balanced and enjoyable gaming experience.

// You can start by implementing the basic functionality for the first few levels and then gradually add more complexity and features as you progress through the development process. This approach allows you to build a solid foundation and iteratively enhance the game based on feedback and testing.

// Let me know if you have any further questions or if you'd like me to elaborate on any specific aspect of the level design or game mechanics.



////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// //Enemy movement




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
css:
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

* {
    margin: 0;
    padding: 0;
    color: white;
    font-family: 'Press Start 2P';
}

body {
    background-color: black;
    height: 100vh;
    display: grid;
    grid-template-columns: 1fr 80vh 1fr;
    grid-template-rows: auto;
    grid-template-areas: 
        "header header header"
        "lboard main score"
        "lboard main controls";
    align-items: center;
    justify-items: center;
}

header {
    grid-area: header;
    text-align: center;
}


.startDiv {
    position: absolute;
    display: flex;
    height: 100vh;
    align-items: center;
    justify-content: center;
}

.startDiv div {
	background-color: #ccc;
    z-index: 100;
	cursor: pointer;
	border-radius: 20px;
	box-shadow: 4px 4px 4px #000;
    padding: 20px 30px;
    display: flex;
    height: 32px;
}

.startDiv h1 {
    text-shadow: 2px 2px 2px #000;
	font-size: 2em;
    text-decoration: none;
    margin-left: 10px;
}

header h1 {
    font-size: 4em;
    background: linear-gradient(45deg, #ffde00, #b7ff00 50%, #ff0000 50%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

main {
    grid-area: main;
    display: grid;
    grid-template-columns: repeat(10, 10%);
    width: 80vh;
    height: 80vh;
    align-items: center;
    justify-items: center;
}

/* Lives styling */
.lives {
    position: absolute;
    top: 0;
    right: 0;
    height: auto;
    display: flex;
    align-items: center;
    margin: 0.5em;
}

.lives li {
    list-style: none;
    background-color: yellow;
    width: 2em;
    height: 2em;
    border-radius: 100%;
    margin: 5px;
}

.lives ul {
    display: flex;
}

.score {
    grid-area: score;
}

.leaderboard {
    grid-area: lboard;
}

.leaderboard ol {
    margin-left: 2.5em;
    margin-top: 1em;
    text-align: left;
}

.leaderboard ol li {
    font-size: 0.85em;
    padding: 1em 0;
}

div {
    height: 100%;
    text-align: center;
}

div h1 {
    font-size: 1.25em;
    text-decoration: underline;
}

div p {
    margin: 0.5em;
    font-size: 2em;
}

#player {
    background-color: yellow;
    border-radius: 100%;
    position: relative;
    width: 85%;
    height: 85%;
}

.enemy {
    background-image: url('space-invader.png'); /* Add a space invader image */
    background-size: 100% 100%;
    width: 30px;
    height: 30px;
    position: relative;
  }

.point {
    border-radius: 100%;
    background-color: white;
}

.wall {
    background-color: blue;
    width: 100%;
    height: 100%;
}

/* Styles for the player direction */
.up, .down, .left, .right {
    width: 100%;
    height: 100%;
    background-color: black;
    animation: mouth 1.25s infinite steps(1, end);
    position: absolute;
    top: 0;
    left: 0;
}

.up { clip-path: polygon(0 0, 100% 0, 50% 50%); }
.down { clip-path: polygon(0 100%, 100% 100%, 50% 50%); }
.left { clip-path: polygon(0 0, 0 100%, 50% 50%); }
.right { clip-path: polygon(100% 0, 100% 100%, 50% 50%); }

@keyframes mouth {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}

/* Directional button styling */
.controls {
    grid-area: controls;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    grid-template-areas: 
        ". upArrow ."
        "leftArrow . rightArrow"
        ". downArrow .";
    width: 25vh;
    height: 25vh;
}

button {
    background-color: rgb(10, 10, 10);
}

button:nth-child(1) { grid-area: leftArrow; }
button:nth-child(2) { grid-area: upArrow; }
button:nth-child(3) { grid-area: rightArrow; }
button:nth-child(4) { grid-area: downArrow; }

@keyframes deathAnimation {
    0% {
        transform: scale(1);
    }

    50% {
        transform: scale(0.5);
    }

    100% {
        transform: scale(0);
    }
}

@keyframes hitAnimation {

    0%, 100% {
        background-color: yellow;
        transform: scale(1);
    }

    50% {
        background-color: red;
        transform: scale(0.75);
    }
    
}

.dead {
    animation: deathAnimation 1.5s ease-in-out forwards;
}

.hit {
    animation: hitAnimation 1.5s ease-in-out;
}

/* Styles for the Game Over and Restart buttons to match the Start button */
.restart-btn {
    text-align: center;
    display: inline-block;
    margin: 5px;
    font-weight: bold;
    padding: 10px;
    background-color: lightgray;
    text-shadow: -1px -1px black, 1px 1px white;
    color: gray;
    border-radius: 7px;
    box-shadow: 0 .2em gray;
    cursor: pointer;
    font-family: 'Press Start 2P';
}

.restart-btn:active {
    box-shadow: none;
    position: relative;
    top: .2em;
}

/* Game Over specific styles */
.game-over {
    cursor: none;
    font-size: medium;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.game-over {
    width: 120%;
    height: auto; /* Set the width to 50% of its container */
    margin: 0 auto; /* This will center the div */
    padding: 20px; /* Add some padding inside the div */
    text-align: center; /* Center-align the text inside the div */
    background: rgba(0, 0, 0, 0.7); /* Optional: a semi-transparent black background */
    color: #FFF; /* White text color */
    border-radius: 10px; /* Rounded corners */
    /* Add more styles as needed */
}

.game-over-text {
    font-size: 1.5em; /* Increase font size */
    margin-bottom: 20px; /* Add space below the text */
    /* Other styles as needed */
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
.enemy-container, .enemy2-container {
    height: 90%;
    width: 90%;
    position: absolute;
    top: 0;
    left: 0;
    height: 85%;
    width: 85%;
    transform: scale(0.045); /* Adjust the scale value to make the enemy smaller */
    }
    
    .enemy, .enemy2{
    position: relative;
    height: 100%;
    width: 100%;
    }
    
    .enemy .ear {
    position: absolute;
    top: 14%;
    height: 13%;
    width: 10%;
    background: #B4DEEC;
    }
    
    .enemy .ear-left {
    left: 35%;
    }
    
    .enemy .ear-right {
    right: 35%;
    }
    
    .enemy .ear:before {
    position: absolute;
    top: -100%;
    height: 100%;
    width: 100%;
    background: #B4DEEC;
    content: '';
    }
    
    .enemy .ear-left:before {
    left: -100%;
    }
    
    .enemy .ear-right:before {
    right: -100%;
    }
    
    .enemy .head-top {
    position: absolute;
    top: 26%;
    left: 20%;
    height: 15%;
    width: 60%;
    background: #B4DEEC;
    }
    
    .enemy .head {
    position: absolute;
    top: 40%;
    left: 11.5%;
    height: 15%;
    width: 77%;
    background: #B4DEEC;
    }
    
    .enemy .head .eye {
    position: absolute;
    top: -5%;
    height: 77%;
    width: 12%;
    background: #313332;
    }
    
    .enemy .head .eye-left {
    left: 25%;
    }
    
    .enemy .head .eye-right {
    right: 25%;
    }
    
    .enemy .body {
    position: absolute;
    top: 54%;
    left: 10%;
    height: 20%;
    width: 80%;
    background: #B4DEEC;
    }
    
    .enemy .body:before,
    .enemy .body:after {
    height: 220%;
    width: 13%;
    background: #B4DEEC;
    position: absolute;
    content: '';
    }
    
    .enemy .body:before {
    left: -10%;
    }
    
    .enemy .body:after {
    right: -10%;
    }
    
    .enemy .arm {
    position: absolute;
    top: 85%;
    height: 13%;
    width: 10%;
    background: #B4DEEC;
    }
    
    .enemy .arm-left {
    left: 35%;
    }
    
    .enemy .arm-right {
    right: 35%;
    }
    
    .enemy .arm:before {
    position: absolute;
    top: -100%;
    height: 100%;
    width: 100%;
    background: #B4DEEC;
    content: '';
    }
    
    .enemy .arm-left:before {
    left: -100%;
    }
    
    .enemy .arm-right:before {
    right: -100%;
    }

 
.checklist {
    grid-area: lboard;
    margin-top: 47em;
    text-align: left;
}

.checklist h2 {
    text-shadow: 2px 2px 2px #000;
    font-size: 0.9em;
    text-decoration: underline;
    margin-left: 10px;
}

.checklist ul {
    margin-left: 1.99em;
    margin-top: 1em;
    text-align: left;
    list-style: none;
}

.checklist ul li {
    font-size: 0.75em;
    padding: 1em 0;
}



html:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AS2</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="images/icon.png" type="image/x-icon">
    <script src="script.js" defer></script>
</head>

<body>

    <header>
        <h1>Snack Man!</h1>
    </header>

    <div class="startDiv">
        <div class="start">
            <img src="images/icon.png" alt="logo">
            <h1>Start</h1>
        </div>
    </div>

    <div class="leaderboard">
        <h1>LeaderBoard:</h1>
        <ol>
            <li>Chris........100</li>
            <li>Mark.........75</li>
            <li>Tom..........50</li>
            <li>John.........45</li>
            <li>John2........40</li>
            <li>John3........35</li>
        </ol>
    </div>

    <div class="checklist">
        <h2>Current Objectives:</h2>
        <ul>
          <li><input type="checkbox" id="collect-points"> Collect 10 points</li>
          <li><input type="checkbox" id="defeat-enemies"> Defeat 3 enemies</li>
          <li><input type="checkbox" id="reach-level"> Reach level 5</li>
        </ul>
      </div>

    <main>
    </main>

    <div class="lives">
        <h1>Lives:</h1>
        <ul>
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>

    <div class="score">
        <h1>Score:</h1>
        <p>0</p>
    </div>

    <div class="controls">
        <button id="lbttn">&#9664;</button> <!-- LEFT -->
        <button id="ubttn">&#9650;</button> <!-- UP -->
        <button id="rbttn">&#9654;</button> <!-- RIGHT -->
        <button id="dbttn">&#9660;</button> <!-- DOWN -->
    </div>

</body>

</html>